/*****************************************************************
PURPOSE: This function detects if a point/points is inside of given NURBS surface(s)
Attention: Please refer to the PDF instructional manual for detailed information about machine setup
	   and syntax. A sample input file is also provided.
Instructions
  SYNTAX: test_result = PointLocation (srf, Number_of_particles, A_list_of_patch_size, TestPoints)
--------------------------------------------------------------------------------------------------
  INPUT: 1) srf: NURBS surface generated by the igesToolBox. Each patch of the NURBS surface contains the following
	         information.
 *          1) form
 *          2) dim
 *          3) number: [1,2]
 *          4) coefs: [4,nCtr1,nCtr2]
 *          5) knots: cell[1,2]
 *          6) order: [1,2]
	 2) Number_of_particles: a integer that specifies the amount of particles to be read. Please note 
 				 particle is different from a patch. A particle can contain multiple patches.
	 3) A_list_of_patch_size: a N by 1 or 1 by N matrix that specifies the number of patches that each particle
                                  contains.
         4) TestPoints: the points to be tested [n,3]

--------------------------------------------------------------------------------------------------
 OUTPUT: 1) test_result : for each point, if it is inside ANY of the given NURBS surface, output 2
                                          if it is on the surface of  ANY of the given NURBS surface, output 1
                                          if it is outside any of the given NURBS surface, output 0
--------------------------------------------------------------------------------------------------

Instruction to set up
Install CGAL and SISL if you do not have it installed

To compile the MEX function, open MATLAB, type the following command into the command window then press Enter.
User needs to replace the paths of boost library, CGAL library, MPFR library, and GMP library to the correct values

mex PointLocation.cpp CFLAGS="\$CFLAGS -fopenmp" LDFLAGS="\$LDFLAGS -fopenmp" –ICGAL_INCLUDE_DIR –IBOOST_INCLUDE_DIR –ISISL_INCLUDE_DIR –LBOOST_LIB_DIR -lboost_system –LCGAL_LIB_DIR –lCGAL –LSISL_LIB_DIR –lsisl
Replace the underlined paths in the command above according to the system you use, 

Attention: do NOT put spaces between -I or -L and paths that follow them
Now the MEX executable should be built successfully

Note:
A list of supported compilers can be found here: http://www.mathworks.com/support/compilers/R2015a/index.html
To choose a compiler: http://www.mathworks.com/help/matlab/matlab_external/choose-c-or-c-compilers.html
Details about linking libraries: http://www.mathworks.com/help/matlab/ref/mex.html#syntax
Some codes were modified from examples in stackoverflow.com and http://doc.cgal.org/latest/Manual/packages.html


University of Illinois at Urbana-Champagin, Aerospace
Created by Meng Feng on 12/16/2015
Copyright 2015 University of Illinois at Urbana-Champaign. All rights reserved
Mex function utilizing the SISL library.
Contact info: mfeng9@illinois.edu
Last update: 12/19/2015
Special thanks to Masoud Safdari, Qi Dang, and Marcus Hwai Yik Tan 
who provided timely help during the process of coding
*******************************************************************/
#include "mex.h"
#include "sisl.h"
#include <omp.h>
#include <iostream>
#include <string>
#include <sstream>
#include <fstream>
//#include <list>
#include <stdio.h>
#include <math.h>
//#include <ctime>
#include <cstdlib>
#include <stdlib.h>
//CGAL Libraries
#include <CGAL/Simple_cartesian.h>
#include <CGAL/AABB_tree.h>
#include <CGAL/AABB_traits.h>
#include <CGAL/Polyhedron_3.h>
#include <CGAL/boost/graph/graph_traits_Polyhedron_3.h>
#include <CGAL/AABB_face_graph_triangle_primitive.h>
#include <CGAL/AABB_triangle_primitive.h>
#include <CGAL/Polyhedron_incremental_builder_3.h>
// IO
#include <CGAL/IO/Polyhedron_iostream.h>
#include <CGAL/Bbox_3.h>

#define TRIALS 3
#define N1 20
#define N2 20

//#define NUM_THREADS 2 //atoi(getenv("NUM_OF_THREADS"));
//ypedef CGAL::Exact_predicates_inexact_constructions_kernel K;
typedef CGAL::Simple_cartesian<double> K;
typedef K::FT FT;
typedef K::Point_3 Point;
typedef K::Plane_3 Plane;
typedef K::Vector_3 Vector;
typedef K::Ray_3 Ray;
typedef CGAL::Bbox_3 Bbox;
typedef CGAL::Polyhedron_3<K> Polyhedron;
typedef CGAL::AABB_face_graph_triangle_primitive<Polyhedron> Primitive;
typedef CGAL::AABB_traits<K, Primitive> Traits;
typedef CGAL::AABB_tree<Traits> Tree;
typedef Tree::Primitive_id Primitive_id;
typedef Polyhedron::HalfedgeDS HalfedgeDS;

//generate a random number in a given range (referred from AABB_Tree demo code)
FT random_in(const double a, const double b)
{
    srand (time(NULL));
    FT r = rand() / (double)RAND_MAX;
    return (a + (b - a) * r);
}

//generate a random vector (referred from AABB_Tree demo code)
Vector random_vector()
{
    FT x = random_in(0.0,1.0);
    FT y = random_in(0.0,1.0);
    FT z = random_in(0.0,1.0);
    return Vector(x,y,z);
}

//generate a random point inside the current bounding box (referred from AABB_Tree demo code)
Point random_point(const CGAL::Bbox_3& bbox)
{
    FT x = random_in(bbox.xmin(),bbox.xmax());
    FT y = random_in(bbox.ymin(),bbox.ymax());
    FT z = random_in(bbox.zmin(),bbox.zmax());
    return Point(x,y,z);
}

//generate a random ray towards the current bounding box (referred from AABB_Tree demo code)
Ray random_ray(const CGAL::Bbox_3& bbox)
{
    Point p = random_point(bbox);
    Point q = random_point(bbox);
    return Ray(p,q);
}

FT random_coord (double min, double max)
{
    double f = (double)rand() / RAND_MAX;
    return min + f * (max - min);
}


// test if a point is within a bounding box
bool outofBbox (const Point &p, const Bbox& bbox)
{
    double safe_factor = 1e-3; 
    if (p.x() < bbox.xmin() - safe_factor || p.x() > bbox.xmax() + safe_factor)
    {
        //std::cout << "x out of range" << std::endl;
        return true;
    }
    else if (p.y() < bbox.ymin() - safe_factor || p.y() > bbox.ymax() + safe_factor)
    {
        //std::cout << "y out of range" << std::endl;
        return true;
    }
    else if (p.z() < bbox.zmin() - safe_factor || p.z() > bbox.zmax() + safe_factor)
    {
        //std::cout << "z out of range" << std::endl;
        return true;
    }
    else
    {
        //std::cout << "in some box" << std::endl;
        return false;
    }
    
}

void write_to_OFF_file (double (&vertices)[N1*N2][3], int (&conn)[2*(N1-1)*(N2-1)][3])
{
    // Generate OFF file
    // create an instance of ofstream, and opens it
    std::ofstream polyhedron_file ("polyhedron.off");
    // write file header
    polyhedron_file << "OFF" << std::endl;
    polyhedron_file << "# Sample Polyhedron Surface \n" << std::endl;
    // number of vertices, faces, and edges (default to be 0)
    polyhedron_file << N1*N2 << " " << 2*(N1-1)*(N2-1) << " 0" <<std::endl;
    // write vertices
    for (int i = 0; i < N1*N2; i++)
    {
        polyhedron_file << vertices[i][0] << " "
                        << vertices[i][1] << " "
                        << vertices[i][2] << std::endl;                
    }
    // write triangles
    for (int i = 0; i < 2*(N1-1)*(N2-1); i++)
    {
        polyhedron_file << "3 " << conn[i][0] << " "
                        << conn[i][1] << " "
                        << conn[i][2] << std::endl;
    }
    polyhedron_file.close();
}

std::vector<Point> genGrid (double inc, const CGAL::Bbox_3& bbox)
{
    std::vector<Point> testPts;
    // preload the parameters of the overall bounding box
    FT x_max = bbox.xmax();
    FT x_min = bbox.xmin();
    FT y_max = bbox.ymax();
    FT y_min = bbox.ymin();
    FT z_max = bbox.zmax();
    FT z_min = bbox.zmin();

    //figure out what min and max return
    for (FT x = x_min; x < x_max; x = x + inc)
    {
        for (FT y = y_min; y < y_max; y = y + inc)
        {
            for (FT z = z_min; z < z_max; z = z + inc)
            {
                testPts.push_back(Point (x,y,z));
            }
        }
    }
    return testPts;
}

// Generate AABB tree for a polyhedron
Tree* generate_aabb_tree (const Polyhedron &input_Polyhedron)
{
    Tree* tree = new Tree(faces(input_Polyhedron).first, faces(input_Polyhedron).second, input_Polyhedron);
    // OPTIONAL: prepare for computing squared distance to closest the triangle
    (*tree).accelerate_distance_queries();
    return tree;
}

//Detect whether the point is true(INSIDE) or false(OUTSIDE) using ray tracing method
bool ray_tracing (Point p, const Tree& tree, const Bbox& bbox)
{   
	// Generate 5 random rays, count the number of times even/odd intersections
	int counter_in = 0; //count the number of times getting odd intersection
	int counter_out = 0; // count the number of times getting even intersection
	
    //std::cout << "Perform Ray Testing" << std::endl;
    for (int i = 0; i < TRIALS; i ++) 
	{
		//generate a random ray from point p toward the bounding box
		Point p2 = random_point(bbox); 
        // std::cout << "random point: " << p2 << std::endl;
        Ray ray(p,p2);
		// count the number of intersection(s)
		int nb_intersections = (int) tree.number_of_intersected_primitives(ray);
		if(nb_intersections % 2 != 0)
			counter_in++;
		else
			counter_out++;
	}
/*	std::cout << "counter_in = " << counter_in << std::endl;
    std::cout << "counter_out = " << counter_out << std::endl;
*/    if (counter_in > counter_out)
    {
        return true;
    }
    else
    {
        return false;
    }
}

template <typename T>
  std::string number2string ( T Number )
  {
     std::ostringstream ss;
     ss << Number;
     return ss.str();
  }

template <class HDS>
class polyhedron_builder : public CGAL::Modifier_base<HDS> 
{
    public:
        std::vector<Point> &points;
        std::vector<int> &facets;
        polyhedron_builder ( std::vector<Point> &these_points, std::vector<int> &these_facets) : points(these_points),facets(these_facets){}
        void operator()(HDS& hds)
        {
            typedef typename HDS::Vertex Vertex;
            typedef typename Vertex::Point V_Point;

            int size_of_vertices = points.size();
            int size_of_facets = facets.size();
            CGAL::Polyhedron_incremental_builder_3<HDS> B (hds, true);
            B.begin_surface(size_of_vertices, size_of_facets);

            // add verticies
            for (int i = 0; i < size_of_vertices; i++)
            {
                B.add_vertex(points[i]);
            }

            // add facets
            for (int i = 0; i < size_of_facets; i+=3)
            {
                B.begin_facet();
                // data from MATLAB, needs to minus one to convert
                // indices starting from 0
                B.add_vertex_to_facet (facets[i]);
                B.add_vertex_to_facet (facets[i+1]);
                B.add_vertex_to_facet (facets[i+2]);
                B.end_facet();
            }
            // finish up the surface
            B.end_surface();
        }
};


//generate bounding box of a polyhedron
Bbox generate_bbox (Polyhedron input_Polyhedron)
{
    Bbox temp = Bbox();
    Polyhedron::Point_iterator it = input_Polyhedron.points_begin();
    temp = (*it).bbox();
    for (; it != input_Polyhedron.points_end(); it++)
    {
        temp = temp + (*it).bbox();
    }
/*        std::cout << "Bounding box generated     x:" << temp.xmin() << "--" << temp.xmax() << std::endl;
        std::cout << "                           y:" << temp.ymin() << "--" << temp.ymax() << std::endl;
        std::cout << "                           z:" << temp.zmin() << "--" << temp.zmax() << std::endl;
*/    return temp;
}

// manually specify a point location
Point specifyPoint ()
{
    double x,y,z;
    std::cout << "input test point coords" << std::endl;
    std::cin >> x >> y >> z;
    return Point (x,y,z);
}

int* main_program(const std::vector<Polyhedron> &polyhedrons, const std::vector<Point> &testPts)
{  
   //Generate bounding box for each polyhedron
   const int num_of_polyhedrons = polyhedrons.size();
   Bbox bbox_list [num_of_polyhedrons];
   for (int i = 0; i < num_of_polyhedrons; ++i)
   {
       bbox_list [i] = generate_bbox(polyhedrons[i]);
   }

   //Generate a bounding box that includes all gemotries
   Bbox big_box = bbox_list[0];
   for (int i = 1; i < num_of_polyhedrons; i++)
   {
        big_box = big_box + bbox_list[i];
   }

    std::cout << "Overall Bounding box generated x:" << big_box.xmin() << "--" << big_box.xmax() << std::endl;
    std::cout << "                               y:" << big_box.ymin() << "--" << big_box.ymax() << std::endl;
    std::cout << "                               z:" << big_box.zmin() << "--" << big_box.zmax() << std::endl;
    
    // to test grid points
    int testPts_size = testPts.size();
    std::cout << testPts_size << " grid points received" << std::endl;

    // compute and construct an array of tree for all geometries
    // std::cout << "Generating AABB Tree" << std::endl;
    Tree** tree_list = new Tree* [num_of_polyhedrons];
    for (int i = 0; i < num_of_polyhedrons; i++)
    {
        tree_list[i] = generate_aabb_tree(polyhedrons[i]);
    }

    //construct a location type: query_loc
    // std::cout << "Detecting point locations..." << std::endl;

    double time1 = omp_get_wtime();

    // initialize output table
    int output_cols = 1;
    int* output  = new int [testPts_size];
    for (int x = 0; x < testPts_size; x++)
    {
        output[x] = -1;
    } 

    // start testing
    int i, nthreads;
    omp_set_num_threads(1);
    #pragma omp parallel
    {
        int i, id, nthrds;
        id = omp_get_thread_num();
        // std::cout << "running id: " << id << std::endl;
        nthrds = omp_get_num_threads();
        if (id == 0) nthreads = nthrds;

        for (i = id; i < testPts_size; i = i + nthrds)
        {
            int col_4 = -1;
//---------------------------------------------------------------------------------
            // test if the point is in any of the bounding box, if so, save the index of bbox to in_boxes
            // to access the actual polyhedron
            // polyhedrons[in_boxes[i]]
            std::vector<int> in_boxes;

            for (int j = 0; j < num_of_polyhedrons; ++j)
            {    
                if (! (outofBbox(testPts[i], bbox_list[j])))
                {
                    in_boxes.push_back(j); 
                }
            }
            // if in_boxes is empty, the point must be outside
            if (in_boxes.empty())
            {
                col_4 = 0;
            }
            // if in_boxes is not empty, perform ray tracing to geometries contained by those bboxes
 //----------------------------------------------------------------------------------           
            else
            {
                // std::cout << "Computing squared distance" << std::endl;
                double sqd[in_boxes.size()];
                for (int box_index = 0; box_index < in_boxes.size(); box_index++)
                {
                    // the index of polyhedron we are actually testing
                    int x = in_boxes[box_index];
                    // find and store the distance of the closest triangle
                    Tree *temp = tree_list[x];
                    sqd[box_index] = (*temp).squared_distance(testPts[i]);
                    //std::cout << sqd[box_index] << std::endl;
                }
                
                // find the polyhedron index that correponds to the minimum sqd distance
                double min_sqd = sqd[0];
                int min_sqd_polyhedron = in_boxes[0];
                if (in_boxes.size() > 1)
                {
                    for (int box_index = 1; box_index < in_boxes.size(); box_index++)
                    {
                        // the index of polyhedron we are actually testing
                        int x = in_boxes[box_index];
                        if (sqd[box_index] < min_sqd)
                        {
                            min_sqd = sqd[box_index];
                            min_sqd_polyhedron = x;
                        }
                    }
                }

/*                std::cout << "Point: " << testPts[i] << std::endl;
                std::cout << "min_sqd = " << min_sqd << std::endl;
                std::cout << "min_sqd_polyhedron = " << min_sqd_polyhedron << std::endl;
*/                // if the minimum squared distance is smaller than a set threshold
                if (min_sqd < 1e-5)
                {
                    col_4 = 1; // on the surface of the polyhedron
                }
                else
                {
                    // start ray tracing to the min_sqd_polyhedron
                     if (ray_tracing(testPts[i], *(tree_list[min_sqd_polyhedron]),bbox_list[min_sqd_polyhedron]))
                     {
                        col_4 = 2; // the point is inside the target polyhedron
                     }
                     else
                     {
                        col_4 = 0; // the point is outside the target polyhedron
                     }
                                     
                }     
            }
            # pragma omp critical
            {
                output[i] = col_4;
            }
        }
    }

    double time2 = omp_get_wtime();
    // std::cout << "done (" << time2 - time1 << " s) with " << nthreads << " thread(s)" << std::endl;
    //int total_points_in_polyhedron = 0;
    for (int i = 0; i < testPts_size; i++)
    {
        // for debug purposes
        // if (output[i] != 0)
        //     total_points_in_polyhedron++;
        if (output[i] == -1)
            std::cout << "invalid output data at index " << i << std::endl;
    }

    // delete the data in the heap
    for (int i = 0; i < num_of_polyhedrons; i++)
    {
        delete tree_list[i];
    }
    delete [] tree_list;

    return output;   
}
// ======================================================================================
// int number of particles
// int number of surface for this particles
//--------------------------------------------
// input NURBS is generated by Octave NURBS toolbox
void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
	 //mexPrintf("Validating input...\n");
	 // to validate the input data
     if (nrhs != 4) 
	 {
        mexErrMsgIdAndTxt( "MATLAB:findnz:invalidNumInputs",
                "4 inputs required.\n");
     }

     if (nlhs == 0) 
     {
        mexPrintf("Outputing results to ans...\n");
     }
//-----------------------------------------------------------
    //mexPrintf("Loading input...\n");
    // load grid of points to be tested
    double* to_grid = mxGetPr(prhs[3]); // matrix
    int grid_num_of_rows = (int) mxGetM(prhs[3]);
    std::vector<Point> grid;
    for (int i = 0; i < grid_num_of_rows; i++)
    {
       grid.push_back(Point (to_grid[i], to_grid[grid_num_of_rows + i], to_grid[2 * grid_num_of_rows + i]));
    }
        
    // load the number of particles and the list of patch sizes
    double* patch_num = mxGetPr(prhs[2]);
    double* particle_num = mxGetPr(prhs[1]);
    // initialize the container of polyhedrons
    std::vector<Polyhedron> polyhedrons;
       
    for (int i_particle = 0; i_particle < particle_num[0]; i_particle++)
    {
        mxArray* tempParticleStruct;
        tempParticleStruct = mxGetCell(prhs[0], i_particle);
        std::vector<Point> vertices;
        std::vector<int> facets;
        int lastVertexIndex = 0;

        for (mwIndex i_patch = 0; i_patch < patch_num[i_particle]; i_patch++)
        {
            mxArray* tempPatchElement;
            tempPatchElement = mxGetFieldByNumber(tempParticleStruct, i_patch, 2);
            double* number = mxGetPr(tempPatchElement);
            tempPatchElement = mxGetFieldByNumber(tempParticleStruct, i_patch, 3);
            double* coefs = mxGetPr(tempPatchElement);

            tempPatchElement = mxGetFieldByNumber(tempParticleStruct, i_patch, 4);
            mxArray* tempKnot = mxGetCell(tempPatchElement,0);
            double* knot1 = mxGetPr(tempKnot);
            tempKnot = mxGetCell(tempPatchElement,1);
            double* knot2 = mxGetPr(tempKnot);

            tempPatchElement = mxGetFieldByNumber(tempParticleStruct, i_patch, 5);
            double* order = mxGetPr(tempPatchElement);
            SISLSurf* result_surf = NULL;

            /* creating SISL surface nurbs structure */
            // Reconstruct the polyhedrons from NURBS inputs
            // Generate lists of points and connectivities for each surface
            // generate surface
            int dim = 3;
            int kind = 2;
            int copy = 1;
            result_surf = newSurf(number[0], 
                                  number[1], 
                                  order[0], 
                                  order[1], 
                                  knot1, 
                                  knot2, 
                                  coefs, 
                                  kind, 
                                  dim, 
                                  copy);
            
            if (result_surf == NULL)
            {
                mexErrMsgIdAndTxt("sislPlaneSurfInt:newSurf","Error occured inside call to SISL routine newSurf.");
            }
    //--------------------------------------------------------------------------------- 
            // s1603 Pick the Parameter Ranges of a Surface
            // Note: the definition of parameter is vaguely defined in SISL library
            // this function is to assist in finding parameters
            double min1;  // Start parameter in the first parameter direction
            double min2; // Start parameter in the second parameter direction
            double max1; // End parameter in the first parameter direction
            double max2; // End parameter in the second parameter direction
            int s1603stat; // Status messages (>0: warning; =0: ok; <0: error)
            s1603(result_surf, &min1, &min2, &max1, &max2, &s1603stat);
            // std::cout << "Range of parameters" << std::endl;
            // std::cout << "First direction" << std::endl;
            // std::cout << "min = " <<min1<<";  max = " << max1 << std::endl;
            // std::cout << "min = " <<min2<<";  max = " << max2 << std::endl;
            // std::cout<< "status = " << s1603stat<<std::endl;    
    //---------------------------------------------------------------------------------      
            // equally devide parameters into N numbers (equivalent to linspace)
            //int N1 = 10; // subdivision parameter in 1st direction
            //int N2 = 10; // subdivision parameter in 2nd direction
            double step1 = (max1-min1)/(N1-1);
            double step2 = (max2-min2)/(N2-1);
            double parlist1[N1];
            double parlsit2[N2];
            
            for (int i = 0; i < N1; i++)
            {
                parlist1[i] = min1 + step1*i; // parameter list in 1st direction    
            }
            for (int i = 0; i < N2; i++)
            {
                parlsit2[i] = min2 + step2*i; // parameter list in 2nd direction    
            }

    //--------------------------------------------------------------------------------- 
            // Evaluate at each pair of parameters
            int der = 0; // Only position is evaluated
            int leftknot1 = 0;
            int leftknot2 = 0;
            int derive_length = dim*(der+1)*(der+2)/2;
            int counter = 0;
            for(int n = 0; n < N2; n++)
            {
                for (int m = 0; m < N1; m++)
                {
                    double normal[dim];
                    double derive[derive_length];
                    double parvalue[] = {parlist1[m], parlsit2[n]};
                    int s1421stat; //=2: surface is degenerate at the point, normal has zero length
                                   //=1: surface is close to degenerate at the point, angle between
                                   //    tangents is less than the angular tolerance
                                   //=0: OK
                                   //<0: Error
                    s1421(result_surf, der, parvalue, &leftknot1, &leftknot2, derive, normal, &s1421stat);
                    // store the grid points evaluated from nurbs surface
                    vertices.push_back(Point (derive[0], derive[1], derive[2]));
                    counter++;
                }
            }
            // Surface triangulation
            // Theory as follows
            //  |   --> ut                         N1 = 6, N2 = 5
            //  |  (0)  (1)  (2)  (3)  (4)  (5)
            //  V   a----b----c----d----e----f
            //     (6)  (7)  (8)  (9) (10)  (11)
            //      g----h----i----j----k----l
            //  vt  
            //      x----x----x----x----x----x
            //      
            //      x----x----x----x----x----x
            //      
            //      x----x----x----x----x----x
            //   There are N1 points in ut direction and N2 points in vt direction
            //   There will be 2 * (N1-1) * (N2-1) triangules
            //   Triangulation is performed in such a pattern so that a-g-b and b-g-h are two triangules
            for (int vt = 0; vt < N2-1; vt++)
            {
                for (int ut = 0; ut < N1 -1; ut++)
                {
                    // for each square, the first triangle
                    facets.push_back(ut + vt * N1 + lastVertexIndex);
                    facets.push_back(ut + vt * N1 + N1 + lastVertexIndex);
                    facets.push_back(ut + vt * N1 + 1 + lastVertexIndex);
                    // for each square, the second triangle
                    facets.push_back(ut + vt * N1 + 1 + lastVertexIndex);
                    facets.push_back(ut + vt * N1 + N1 + lastVertexIndex);
                    facets.push_back(ut + vt * N1 + N1 + 1 + lastVertexIndex);
                }
            }
            lastVertexIndex = vertices.size();
        }

        Polyhedron P;
        polyhedron_builder<HalfedgeDS> builder (vertices, facets);
        P.delegate(builder);
        polyhedrons.push_back(P);
    }
    
//--------------------------------------------------------------------------------- 

     mexPrintf("%d polyhedrons built...\n", (int) polyhedrons.size());

     // call main_program to compute

     //write_to_OFF_file(vertices, conn);
     
     int* table = main_program(polyhedrons, grid);
     // create blank MATLAB matrix for output
     plhs[0] = mxCreateDoubleMatrix(grid_num_of_rows, 1,mxREAL);
     
     mexPrintf("Writing output...\n");
     double* output = mxGetPr(plhs[0]);

     for (int i = 0; i < grid_num_of_rows; i++)
     {
     	output[i] = table[i];
     }
     mexPrintf("Output generated...\n");
     // free heap
     delete[] table;
     mexPrintf("Heap memory cleared...\n");


}

